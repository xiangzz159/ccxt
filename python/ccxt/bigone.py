# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange

# -----------------------------------------------------------------------------

try:
    basestring  # Python 3
except NameError:
    basestring = str  # Python 2
import hashlib
import math
import json
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import DDoSProtection
from ccxt.base.errors import ExchangeNotAvailable
import time
import datetime


class bigone(Exchange):
    def describe(self):
        return self.deep_extend(super(bigone, self).describe(), {
            'id': 'bigone',
            'name': 'BigOne',
            'countries': 'USA',
            'rateLimit': 1000,
            'version': None,
            'has': {
                'CORS': False,
                'create': False,
                'fetchOrder': True,
                'fetchOrders': False,
                'fetchCloseOrders': False,
                'withdraw': True,
            },
            'urls': {
                'logo': 'https://big.one/assets/icons-49607d33ce9fc8cdcf62d9f51a73ddc7-favicon-32x32.png',
                'api': {
                    'public': 'https://api.big.one',
                    'private': 'https://api.big.one',
                },
                'www': 'https://big.one/',
                'doc': 'https://developer.big.one/',
            },
            'api': {
                'public': {
                    'get': [
                        'markets',
                        'markets/{symbol}',
                        'markets/{symbol}/book',
                        'markets/{symbol}/trades',
                        'trades',
                    ],
                },
                'private': {
                    'get': [
                        'accounts',
                        'accounts/{currency}',
                        'orders',
                        'orders/{id}',
                        'withdrawals',
                    ],
                    'post': [
                        'orders',
                        'orders/cancel',
                        'withdrawals',
                    ],
                    'delete': [
                        'orders/{id}',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'marker': 0.1 / 100,
                },
            },
        })

    def fetch_markets(self):
        response = self.publicGetMarkets()
        markets = response['data']
        result = []
        for market in markets:
            symbol = market['symbol']
            base = market['base']
            quote = market['quote']
            type = market['type']
            id = base
            result.append({
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'info': type,
                'lot': None,
                'active': True,
                'market': base,
                'precision': {
                    'amount': 8,
                    'price': 8,
                },
                'limits': {
                    'amount': {
                        'min': None,
                        'max': None,
                    },
                    'price': {
                        'min': None,
                        'max': None,
                    },
                    'cost': {
                        'min': None,
                        'max': None,
                    },
                },
            })
        return result

    def fetch_balance(self, params={}):
        self.load_markets()
        response = self.privateGetAccounts()
        data = response['data']
        result = {'info': response}
        for balance in data:
            currency = balance['account_type']
            account = self.account()
            account['total'] = float(balance['active_balance']) + float(balance['frozen_balance'])
            account['used'] = float(balance['frozen_balance'])
            account['free'] = float(balance['active_balance'])
            result[currency] = account
        return self.parse_balance(result)

    def fetch_order_book(self, symbol):
        self.load_markets()
        request = {
            'symbol': self.market_id(symbol),
        }
        response = self.publicGetMarketsSymbolBook(self.extend(request))
        orderbook = response['data']
        return self.parse_order_book(orderbook, None, 'bids', 'asks', 'price', 'amount')

    def fetch_tickers(self):
        response = self.fetch_markets()
        tickers = response['data']
        result = {}
        for i in range(0, len(tickers)):
            ticker = tickers[i]
            parsedTicker = self.parse_ticker(ticker)
            symbol = parsedTicker['symbol']
            result[symbol] = parsedTicker
        return result

    def fetch_ticker(self, symbol):
        self.load_markets()
        request = {
            'symbol': self.market_id(symbol),
        }
        response = self.publicGetMarketsSymbol(self.extend(request))
        ticker = response['data']
        market = self.market(symbol)
        return self.parse_ticker(ticker, market)

    def parse_ticker(self, ticker, market=None):
        timestamp = float(time.time() * 1000)
        trades = ticker['trades']
        bid = None
        ask = None
        for i in range(0, len(trades)):
            if bid is not None and ask is not None:
                trade = trades[i]
                if trade['trade_side'] == 'BID':
                    bid = trade
                if trade['trade_side'] == 'ASK':
                    ask = trade
        return {
            'symbol': ticker['symbol'],
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': float(ticker['ticker']['high']),
            'low': float(ticker['ticker']['low']),
            'bid': bid['price'],
            'bidVolume': bid['amount'],
            'ask': ask['price'],
            'askVolume': ask['amount'],
            'vwap': None,
            'open': float(ticker['ticker']['open']),
            'close': float(ticker['ticker']['close']),
            'last': float(ticker['ticker']['price']),
            'previousClose': None,
            'change': None,
            'percentage': None,
            'average': None,
            'baseVolume': None,
            'quoteVolume': None,
            'info': ticker,
        }

    def parse_trade(self, trade, market):
        dt = trade['created_at']
        if '.' in dt:
            index = dt.index('.')
            dt = dt[0:index]
        # 转换成时间数组
        timeArray = time.strptime(dt, "%Y-%m-%dT%H:%M:%S")
        # 转换成时间戳
        timestamp = time.mktime(timeArray)

        side = trade['trade_side'].lower()
        tradeId = trade['trade_id']
        price = float(trade['price'])
        amount = float(trade['amount'])
        return {
            'id': tradeId,
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': market['symbol'],
            'type': None,
            'order': None,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': None,
            'fee': None,
        }

    def fetch_trades(self, symbol, since=None, limit=50, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            "symbol": market['id'],
        }
        response = self.publicGetMarketsSymbolTrades(self.extend(request))
        return self.parse_trades(response['data'], market, since, limit)

    def create_order(self, symbol, type, side, amount, price):
        self.load_markets()
        request = {
            'order_market': symbol,
            'order_side': side.upper(),
            'price': str(price),
            'amount': str(amount)
        }
        response = self.privatePostOrders(request)
        order = self.parse_order(response)
        id = order['id']
        self.orders[id] = order
        return self.extend({'info': response}, order)

    def parse_order(self, order):
        data = order['data']
        id = data['order_id']
        symbol = data['order_market']
        order_type = data['order_type']
        dt = data['created_at']
        if '.' in dt:
            index = dt.index('.')
            dt = dt[0:index]
        # 转换成时间数组
        timeArray = time.strptime(dt, "%Y-%m-%dT%H:%M:%S")
        # 转换成时间戳
        timestamp = time.mktime(timeArray)

        result = {
            'info': data,
            'id': id,
            'timestamp': timestamp,
            'symbol': symbol,
            'type': data['order_type'].lower(),
            'side': data['order_side'].lower(),
            'price': self.safe_float(data, 'price'),
            'amount': self.safe_float(data, 'amount'),
            'filled': self.safe_float(data, 'filled_amount')
        }
        return result

    def cancel_order(self, id, symbol=None, params={}):
        self.load_markets()
        response = self.privateDeleteOrdersId(self.extend({'id': id}, params))
        return self.extend({'info': response})

    def fetch_order(self, id, symbol=None, params={}):
        self.load_markets()
        request = {
            "id": id
        }
        response = self.privateGetOrdersId(self.extend(request, params))
        return self.parse_order(response)


    def request(self, path, api='public', method='GET', params={}, headers=None, body=None):
        response = self.fetch2(path, api, method, params, headers, body)
        return response

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        url = self.urls['api'][api]
        request = self.implode_params(path, params)
        url += '/' + request
        query = self.omit(params, self.extract_params(path))
        if api == 'public':
            if query:
                url += '?' + self.urlencode(query)
        else:
            headers = {
                'Accept': 'application/json',
                'User-Agent': 'python-bigone',
                'Authorization': 'Bearer {}'.format(self.secret),
                'Big-Device-Id': self.apiKey,
            }
            if method == 'GET':
                url += '?' + self.urlencode(params)
            else:
                body = self.json(params)
        return {'url': url, 'method': method, 'body': body, 'headers': headers}
